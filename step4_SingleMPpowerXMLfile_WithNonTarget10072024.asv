%% Load Data
clear all
% ProcessFolder='F:\LuSLMOnlineTest\04222024\SingleP\30PixelFromEdgeExc\';
load('C:\Users\User\Project-SLMonlineControl\subfun\Color\colorMapPN3.mat');
ConfigFolder='C:\Users\User\Project-SLMonlineControl\config\';
ConfigFile='SLMsetting.yml';%<----------------------------------------------------------------------------------Edit, configuration file
[~,~,~,CaData,CaDataPlane,stat,yaml,confSet]=ROIToXYZ(ConfigFolder);
umPerPixel=mean([yaml.umPerlPixelX yaml.umPerlPixelY]);
ProcessFolder='E:\LuSLMOnlineTest\SL0777-Ai203\10302014\SingleP\Top13SpeedStimEdgeExc\';%<----------------------Edit, Data folder

step4_SubStep1_LoadData;



%% 
% RandomDelayInterval=[0 1]; %%Random delay is induced after each trial of stimulation.
% PointRepetition=1;  %%Trial Number per each xml MarkPoint stimulation.
PreMarkPointRepetition=34;    %<----------------------------------------------------------------------------------Edit,Frame # before SLM in PV
PostMarkPointRepetition=6;   %<----------------------------------------------------------------------------------Edit,Frame # after SLM in PV
PreSLMCal=15;                 %<----------------------------------------------------------------------------------Edit,Frame # before SLM to calculate baseline map
PostSLMCal=3;                 %<----------------------------------------------------------------------------------Edit,Frame # before SLM to calculate responsive map
% ROIparam.LaserPower=confSet.UncagingLaserPower;  %Laser power to test, using all possible power levels
% ROIparam.LaserPower=confSet.UncagingLaserPower([2 3]);  %<--------------------------------------------------------Edit,It is not necessary to test all possible power levels

step4_SubStep2_PreparingParam;




%% Intiate 1st round test
XMLparam.Laser=1.5;               %<-------------------------------------------------------------------------------Edit, starting laser power to test    
XMLparam.RoundID=1;               %starting round
PointAll=1:size(Pos3Dneed,1);     %All possible MarkPoints for testing
PointsTest=PointAll;              %Initial test Points, this would be updated automatically later

SLMTrialInfo=[];                  %Inital response information, automatically updated after each single trial test
SLMTrialMap=[];                   %Inital response map, automatically updated after each single trial test
clear SLMTable;
SLMTable(:,1)=round(1:size(Pos3Dneed,1));
SLMTable(:,2)=NaN;

FileIDrange=[];                   %<-------------------------------------------------------------------------------Edit, BinFile ID range to calculate SLMresponse
minTrialN=1;
% PointTest=PointAll;
ROIparam.PointsTest=PointsTest;
ROIparam.Clim=[-400 400];
SLMTestParam.TerminalTrialN=4;    %<-------------------------------------------------------------------------------Edit, Trials # to define SLM responsive cells
SLMTestParam.ExcludeTrialN=1;     %<-------------------------------------------------------------------------------Edit, Trials # to define Non-SLM responsive cells
SLMTestParam.AllLaserPower=confSet.UncagingLaserPower;
ROIparam.LaserPower=confSet.UncagingLaserPower;

ROIparam.min_merged_region_size=30;
ROIparam.threshold_percentage=0.3;

ROIparam.max_distance=8;
%% Keep alternating following 2 lines to do all necessary SLM tests and online analysis
step4_SubStep3_InitiateTest



% FileIDrange=[1;400];             %<------------------------------------------------------------------------------Edit, BinFile ID range to calculate SLMresponse
[SLMRes,sampleN]=SLMResponseROIMap(SLMTrialMap,SLMTrialInfo,ROIparam,minTrialN,SumDataFolder,FileIDrange);


ROIparam.LaserPower=confSet.UncagingLaserPower([1 2 3]);  %<-------------------------------------------------------Edit,It is not necessary to test all possible power levels
[UpdateXml, SLMTable, PointsTest, XMLparam, InfoListByLaser]=step3Fun_NextSLMtest(SLMRes,sampleN,ROIparam,XMLparam,SLMTestParam,SLMTable);

% PointsTest=[1 2 3 4];
% XMLparam.Laser=1.5;
% PSTHparam.Plot=1;

%% Save results and generate final MarkPoints and Functional groups
SLMTableOrigin=SLMTable;
% PostSLMTable;
FalsePositiveID=input('Mannual correction: index in SLMTable with false positive error: ');
SLMTable(FalsePositiveID,:)=nan;

save([SumDataFolder 'SLMResponseTable.mat'],'SLMTableOrigin','SLMTable','ROIparam','SLMRes','sampleN','SLMTestParam','SLMIncludedIndFromIscell','FunScore','yaml','Cellstat');

% load([SumDataFolder 'SLMResponseTable.mat'],'SLMTable','ROIparam','SLMRes','sampleN','SLMTestParam','SLMIncludedIndFromIscell','FunScore');

SMLTablePowerPV=xmlPower2PVpower(SLMTable(:,2));
refPVpower=max(SMLTablePowerPV);

CellPerGroup=10;
[Group, FinalPos3D, FinalCellstat, FinalFunScore, confSetFinal] = SLMWeightsAssignToFunGroups(FunScore, CellPerGroup, Pos3Dneed, Cellstat, SLMIncludedIndFromIscell, SLMTable, NonTargets, refPVpower, confSet);
save([ProcessFolder 'SLMFunGroup.mat'],'Group','FinalPos3D','FinalCellstat','FinalFunScore','confSetFinal','SLMTableOrigin','SLMTable','ROIparam','SLMRes','sampleN','SLMTestParam','SLMIncludedIndFromIscell','FunScore','yaml','Cellstat');
XYZtoMarkPointFunGroup(ProcessFolder,FinalPos3D,Group,yaml,confSetFinal,FinalCellstat);


